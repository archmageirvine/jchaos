package irvine.util.graphics;

import java.awt.Graphics;
import java.util.Random;

import javax.swing.JFrame;
import javax.swing.SwingUtilities;

import chaos.util.Sleep;
import irvine.tile.TileImage;

/**
 * Routines for a particle based explosion effect.
 * @author Sean A. Irvine
 */
public final class ParticleExplosion {

  /** Colors below this value are just zeroed. */
  private static final int MIN_COLOR_COMPONENT = 5;
  private static final int RGB_MASK = 0xFFFFFF;

  private final TileImage mState0;
  private final TileImage mState1;
  private final int mDecayRate;
  private final Random mRandom = new Random();
  private boolean mCurrent = false; // i.e. mState0
  private int mExplosionFactor = 2;
  private int mDecayCode = 0x1B; // b -> g -> r

  /**
   * Creates a new particle based explosion of the given size and decay rate.
   * The hot point is specified by the pair <code>(x,y)</code>.
   * @param w width
   * @param h height
   * @param decayRate decay rate
   * @param color initial color
   * @param x x-coordinate of hot point
   * @param y y-coordinate of hot point
   * @throws IllegalArgumentException if a parameter is invalid.
   */
  public ParticleExplosion(final int w, final int h, final int decayRate, final int color, final int x, final int y) {
    if (w < 1 || h < 1 || decayRate < 1) {
      throw new IllegalArgumentException();
    }
    mState0 = new TileImage(w, h);
    mState1 = new TileImage(w, h);
    mState0.setPixel(x, y, color);
    mDecayRate = decayRate;
  }

  /**
   * Creates a new particle based explosion of the given size and decay rate.
   * The hot point is near the centre of the image.
   * @param w width
   * @param h height
   * @param decayRate decay rate
   * @param color initial color
   */
  public ParticleExplosion(final int w, final int h, final int decayRate, final int color) {
    this(w, h, decayRate, color, w >> 1, h >> 1);
  }

  /**
   * Set the number of new particles generated by each particle at each step.
   * The default value is 2.  Other small positive integers can be used.
   * Large values will result in a slower effect and not much change in the
   * actual result.
   * @param factor explosion factor
   * @throws IllegalArgumentException if <code>factor</code> is less than 1.
   */
  public void setExplosionFactor(final int factor) {
    if (factor < 1) {
      throw new IllegalArgumentException();
    }
    mExplosionFactor = factor;
  }

  /**
   * Set a value indicating a preference for how color components are decayed.
   * The code consists of concatenated bit pairs which are used from the
   * lowest bits first.  A code of 01 is red, 10 is green, 11 is blue, and
   * 00 finishes the encoding.  The default is 0x1B = 01,10,11 (i.e. first
   * blue, then green, then red), this is appropriate for fire.  Normally
   * the code should be a permutation of the tuples 01, 10, 11 (but this is
   * not checked).
   * @param code an <code>int</code> value
   */
  public void setDecayPreferenceCode(final int code) {
    mDecayCode = code;
  }

  private int decayColor(final int color) {
    // Decay in preference order blue, green, red
    int d = mDecayRate;
    int b = color & 0xFF;
    int g = (color >> 8) & 0xFF;
    int r = (color >> 16) & 0xFF;
    int decayCode = mDecayCode;
    int bits;
    while ((bits = decayCode & 3) != 0) {
      decayCode >>>= 2;
      switch (bits) {
        case 3:
          if (b != 0) {
            b -= mRandom.nextInt(d);
            if (b < MIN_COLOR_COMPONENT) {
              b = 0;
            }
            d >>>= 2;
            ++d;
          }
          break;
        case 2:
          if (g != 0) {
            g -= mRandom.nextInt(d);
            if (g < MIN_COLOR_COMPONENT) {
              g = 0;
            }
            d >>>= 2;
            ++d;
          }
          break;
        default:
          if (r != 0) {
            r -= mRandom.nextInt(d);
            if (r < MIN_COLOR_COMPONENT) {
              r = 0;
            }
            d >>>= 2;
            ++d;
          }
      }
    }
    return (color & ~RGB_MASK) + (r << 16) + (g << 8) + b;
  }

  private void decayAndInsert(final TileImage dest, int x, int y, final int p) {
    y += 1 - mRandom.nextInt(3);
    if (y >= 0 && y < dest.getHeight()) {
      x += 1 - mRandom.nextInt(3);
      if (x >= 0 && x < dest.getWidth()) {
        if ((dest.getPixel(x, y) & RGB_MASK) == 0 || mRandom.nextBoolean()) {
          dest.setPixel(x, y, decayColor(p));
        }
      }
    }
  }

  /**
   * Update the current effect.  Return true while non-zero pixels still
   * exist.
   * @return false if no further image evolution occurs
   */
  public boolean update() {
    final TileImage source, dest;
    if (mCurrent) {
      source = mState1;
      dest = mState0;
    } else {
      source = mState0;
      dest = mState1;
    }
    dest.fill(0xFF000000); // black
    for (int y = 0; y < source.getHeight(); ++y) {
      for (int x = 0; x < source.getWidth(); ++x) {
        final int p = source.getPixel(x, y);
        if ((p & RGB_MASK) != 0) {
          // Darken existing pixel
          if ((dest.getPixel(x, y) & RGB_MASK) == 0 || mRandom.nextBoolean()) {
            dest.setPixel(x, y, decayColor(p));
          }
          // And insert some new ones at shifted locations
          for (int k = 0; k < mExplosionFactor; ++k) {
            decayAndInsert(dest, x, y, p);
          }
        }
      }
    }
    mCurrent ^= true;
    for (int y = 0; y < dest.getHeight(); ++y) {
      for (int x = 0; x < dest.getWidth(); ++x) {
        if ((dest.getPixel(x, y) & RGB_MASK) != 0) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Return the current image.
   * @return the image
   */
  public TileImage image() {
    return mCurrent ? mState1 : mState0;
  }


  /**
   * Testing.
   * @param args ignored
   */
  public static void main(final String[] args) {
    final ParticleExplosion pe = new ParticleExplosion(48, 48, 5, 0xFFFFE030, 24, 44);
    final JFrame f = new JFrame("test");
    SwingUtilities.invokeLater(() -> {
      f.setSize(500, 500);
      f.setVisible(true);
      final Graphics g = f.getGraphics();
      if (g != null) {
        while (pe.update()) {
          g.drawImage(pe.image().toBufferedImage(), 20, 20, null);
          Sleep.sleep(10);
        }
        g.dispose();
      }
      f.dispose();
      System.exit(1);
    });
  }
}
